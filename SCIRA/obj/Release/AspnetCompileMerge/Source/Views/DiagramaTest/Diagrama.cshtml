@using Syncfusion.EJ2.Diagrams;
@using Syncfusion.EJ2.Navigations;

@{
    Layout = "~/Views/Shared/_LayoutIndex.cshtml";
    ViewBag.Title = "Diagrama";
}

<h2>Diagrama</h2>


    <div class="control-section">
        <div id="swimlaneDiagram" style="width: 100%; height: 600px">
            <div class="sb-mobile-palette-bar">
                <div id="palette-icon" style="float: right;" role="button" class="e-ddb-icons1 e-toggle-palette"></div>
            </div>
            <div id="palette-space" class="sb-mobile-palette">
                @(Html.EJS().SymbolPalette("symbolPalette").Palettes(ViewBag.Palette).GetSymbolInfo("getSymbolInfo").ExpandMode(ExpandMode.Multiple).Width("100%").Height("570px")
                                .SymbolHeight(48).SymbolWidth(48).SymbolMargin(ViewBag.margin).GetNodeDefaults("getSymbolNodes").Render()
                )
            </div>
            <div id="diagram-space" class="sb-mobile-diagram">
                @(Html.EJS().Diagram("container").Width("100%").Height("100%").DragEnter("dragEnter").ContextMenuOpen("contextMenuOpen").ContextMenuClick("contextMenuClick").ContextMenuSettings(c=>c.Show(true).ShowCustomMenuOnly(true).Items(ViewBag.items)).SnapSettings(new Syncfusion.EJ2.Diagrams.DiagramSnapSettings() { Constraints = Syncfusion.EJ2.Diagrams.SnapConstraints.None }).SelectedItems(new DiagramSelector() { Constraints=SelectorConstraints.All &~SelectorConstraints.Rotate})
                               .GetConnectorDefaults("getConnectorDefaults").GetNodeDefaults("getNodeDefaults").Nodes(ViewBag.nodes).Connectors(ViewBag.connectors).Render()
                )
            </div>
        </div>
    </div>
    <style>
        .sb-mobile-palette {
            width: 220px;
            height: 570px;
            float: left;
        }

        .sb-mobile-palette-bar {
            display: none;
        }

        .sb-mobile-diagram {
            width: calc(100% - 222px);
            height: 570px;
            float: left;
            border: 1px solid rgba(0, 0, 0, 0.12);
            border-left: none;
        }

        @@media (max-width: 550px) {
            .sb-mobile-palette {
                z-index: 19;
                position: absolute;
                display: none;
                transition: transform 300ms linear, visibility 0s linear 300ms;
                width: 39%;
                height: 100%;
            }

            .sb-mobile-diagram {
                width: 100%;
                height: 100%;
                float: left;
                left: 0px;
            }

            .sb-mobile-palette-bar {
                display: block;
                width: 100%;
                background: #fafafa;
                padding: 10px 10px;
                border: 0.5px solid #e0e0e0;
                min-height: 40px;
            }

            #palette-icon {
                font-size: 20px;
            }
        }

        .sb-mobile-palette-open {
            position: absolute;
            display: block;
            right: 15px;
        }

        .material #swimlaneDiagram #palette-space .e-accordion {
            border: none;
        }

        .material #swimlaneDiagram #palette-space {
            border: 1px solid rgba(0, 0, 0, 0.12);
        }

        .fabric #swimlaneDiagram .sb-mobile-diagram {
            border-left: 1px solid rgba(0, 0, 0, 0.12);
        }

        .bootstrap #swimlaneDiagram .sb-mobile-diagram {
            height: 554px;
            margin-top: 5px;
            border-radius: 4px;
            border-left: 1px solid rgba(0, 0, 0, 0.12);
        }
    </style>

    <script>
        function getConnectorDefaults(connector) {
            if (connector.id.indexOf("Link21") !== -1) {
                connector.type = 'Straight';
            }
            else if (connector.id.indexOf("Link22") !== -1) {
                connector.type = 'Straight';
            }
            else {
                connector.type = 'Orthogonal';
            }
            connector.style.strokeColor = "black";
            connector.sourceDecorator.style.strokeColor = "black";
            connector.targetDecorator.style.strokeColor = "black";
            connector.sourceDecorator.style.fill = "black";
            connector.targetDecorator.style.fill = "black";
            return connector;
        }
        function getSymbolInfo(symbol) {
            return { tooltip: symbol.addInfo ? symbol.addInfo.tooltip : symbol.id };
        }
        function getSymbolNodes(symbol, diagram) {
            if (symbol.id === 'Terminator' || symbol.id === 'Process' || symbol.id === 'Document' || symbol.id === 'PreDefinedProcess' || symbol.id === 'data' || symbol.id === 'stackCanvas1' || symbol.id === 'stackCanvas2') {
                symbol.style.strokeWidth = 1;
            }
            symbol.style.strokeColor = "#757575"
        }
        function getNodeDefaults(node) {
            node.style.strokeColor = "black";
            return node;
        }
        function dragEnter(arg) {
            if (arg.element) {
                let shape = arg.element.shape;
                if (shape.isLane) {
                    if (shape.orientation === 'Horizontal') {
                        shape.lanes[0].height = 100;
                        shape.lanes[0].width = 500;
                    } else if (shape.orientation === 'Vertical') {
                        shape.lanes[0].height = 500;
                        shape.lanes[0].width = 100;
                    }
                }
            }
        }

        function contextMenuClick(args) {
            var diagram = document.getElementById("container").ej2_instances[0];
            if (args.item.id === 'InsertLaneBefore' || args.item.id === 'InsertLaneAfter') {
                if (diagram.selectedItems.nodes.length > 0 && diagram.selectedItems.nodes[0].isLane) {
                    var index;
                    var node = diagram.selectedItems.nodes[0];
                    var swimlane = diagram.getObject(diagram.selectedItems.nodes[0].parentId);
                    var shape = swimlane.shape;
                    var existingLane = ej.diagrams.cloneObject(shape.lanes[0]);

                    var newLane = {
                        id: ej.diagrams.randomId(),
                        header: {
                            width: existingLane.header.width, height: existingLane.header.height,
                            style: existingLane.header.style
                        },
                        style: existingLane.style,
                        height: existingLane.height, width: existingLane.width,
                    };

                    if (shape.orientation === 'Horizontal') {
                        var exclude = 0;
                        exclude += (shape.header) ? 1 : 0;
                        exclude += (shape.phases.length) ? 1 : 0;
                        index = node.rowIndex - exclude;
                        newLane.header.width = existingLane.header.width;
                        newLane.header.height = existingLane.height;
                    } else {
                        index = node.columnIndex - (shape.phases.length) ? 1 : 0;
                        newLane.header.width = existingLane.width;
                        newLane.header.height = existingLane.header.height;
                    }
                    if (args.item.id === 'InsertLaneBefore') {
                        diagram.addLanes(swimlane, [newLane], index);
                    } else {
                        diagram.addLanes(swimlane, [newLane], index + 1);
                    }
                    diagram.clearSelection();
                }
            } else if (args.item.id === 'Cut') {
                diagram.cut();
            } else if (args.item.id === 'Clone') {
                diagram.copy();
                diagram.paste();
            }
        }

        function contextMenuOpen(args) {
            var diagram = document.getElementById("container").ej2_instances[0];
            for (var item of args.items) {
                if ((diagram.selectedItems.connectors.length + diagram.selectedItems.nodes.length) > 0) {
                    if (item.id === 'InsertLaneBefore' || item.id === 'InsertLaneAfter') {
                        if (diagram.selectedItems.connectors.length || (diagram.selectedItems.nodes.length && !diagram.selectedItems.nodes[0].isLane)) {
                            args.hiddenItems.push(item.text);
                        }
                    }
                } else {
                    args.hiddenItems.push(item.text);
                }
            }
        }
    </script>

